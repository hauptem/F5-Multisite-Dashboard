# LTM_Dashboard-Frontend_v1.7.1_irule
# Dashboard Version 1.7 
# JSON Version 1.7
# Date: September 2025
# Author: Eric Haupt
# License: MIT
# Copyright (c) 2025 Eric Haupt
# Released under the MIT License. See LICENSE file for details.
#
# Description:
#   This iRule provides a multi-site pool monitoring dashboard frontend meant to work with
#   Dashboard API hosts as remote back-end sites serving pool data and DNS.
#   Dashboard v1.7 is not multi-partition compatible. 
#   
# Dashboard Front-End Critical Dependencies:
#
#    1. Front-end LTM datagroup: datagroup-dashboard-clients
#		Type: Address, Used to restrict dashboard access
#
#    2. Front-end LTM datagroup: datagroup-dashboard-debug
#		Type: Address, Used to limit dashboard debug
#
#    3. Front-end LTM datagroup: datagroup-dashboard-sites
#		Type: String, Used to define dashboard site list
#
#    4. Front-end LTM datagroup: datagroup-dashboard-api-host
#		Type: String, Used to map remote Site name to IP address
#
#    5. Front-end LTM datagroup: datagroup-dashboard-pools
#		Type: String, Used to provide a list of pools to display
#
#    6. Front-end LTM datagroup: datagroup-dashboard-pool-alias
#		Type: String, Used to create alias names for actual pool names
#
#    7. Front-end LTM datagroup: datagroup-dashboard-api-keys
#		Type: String, Used to authenticate Front-end to API host.
#
#    8. Front-end LTM pool: dashboard-api-hosts_https_pool
#       This pool contains the API Host IPs for monitoring
#
#    9. Front-end LTM Pool: dashboard-dns_udp53_pool
#       This pool contains the DNS listener for monitoring
#
#   10. LTM dns-resolver: /Common/dashboard-DNS
#       This resolver should map to a GTM listener dedicated for dashboard and scoped for in-addr.arpa.
#
#   11. Front-end LTM APM session variable: session.custom.dashboard.auth
#       This variable must be equal to 1 for this irule to trigger
#
#   12. iFiles: 
#        dashboard_js-core.js   - Javascript Core Module
#        dashboard_js-client.js - Javascript Client Module
#        dashboard_js-data.js   - Javascript Data Module
#        dashboard_js-ui.js     - Javascript UI Module
#        dashboard_js-logger.js - Javascript Logs Module
#        dashboard_logo.png     - logo image file
#        dashboard_themes.css  	- Dashboard CSS with themes
#
when CLIENT_ACCEPTED {
# ======================================================================================================
# USER CONFIGURATION VARIABLES - Set Debug, DNS, Dashboard pool names, Resolver name, and Front-End Name

    # Dashboard Debug toggle - set to 1 to enable Dashboard debug, 0 to disable
    set debug_enabled 0

    # Dashboard DNS toggle - set to 1 to enable Dashboard DNS, 0 to disable
    set dns_enabled 1

    # Dashboard Pool Names - Update these pool name variables to match your environment
    set dashboard_api_hosts_pool "dashboard-api-hosts_https_pool"
    set dashboard_dns_pool "dashboard-dns_udp53_pool"
    
    # Dashboard Front-End Site Name - This must match your site name desired for the Front-end
    set local_site_name "CHICAGO"

# END USER CONFIGURATION VARIABLES - Do not modify any variables below this line
# ======================================================================================================
    # Validate client authorization for debug logging 
    set client_debug_enabled 0
    if { $debug_enabled } {
        if { [class match [IP::client_addr] equals datagroup-dashboard-debug] } {
            set client_debug_enabled 1
        }
    }
    # Enforce access control - restrict to authorized client subnets only
    if { ![class match [IP::client_addr] equals datagroup-dashboard-clients] } {
        if { $debug_enabled } {
            log local0. "DEBUG: Access denied from unauthorized client [IP::client_addr]"
        }
        drop
    }
    # JSON Schema version
    set json_version "1.7"
    # Cache hostname values once
    set bigip_hostname [info hostname]
    regsub -all {"} $bigip_hostname {\"} bigip_hostname_escaped
    # DNS resilience configuration (do not modify this)
    set dns_available 0
    if { $dns_enabled } {
        if { ![catch {active_members $dashboard_dns_pool} active_count] } {
            if { $active_count > 0 } {
                set dns_available 1
            }
        }
    }
}
when HTTP_REQUEST {
    # Validate APM authentication before processing requests
    set dashboard_auth [ACCESS::session data get session.custom.dashboard.auth]
    if { $dashboard_auth != 1 } {
        return
    }
    # Debug logging for request analysis
    if { $client_debug_enabled } {
        log local0. "DEBUG: [HTTP::method] [HTTP::uri] from [IP::client_addr] - Host: [HTTP::host]"
    }
# ======================================================================================================
# LOCAL API ENDPOINT - /api/proxy/pools
# ======================================================================================================
    if { [HTTP::uri] contains "/api/proxy/pools" } {
        # Determine target site from client header
        set selected_site ""
        if { [HTTP::header exists "X-Selected-Site"] } {
            set selected_site [HTTP::header "X-Selected-Site"]
        }
        # Proxy request based on site selection
        if { $selected_site eq "" || $selected_site eq $local_site_name } {
            # Only call if NEED-POOL headers exist
            if { [HTTP::header exists "X-Need-Pools-Count"] } {
                set filtered_pools [call process_headers $client_debug_enabled "pools"]
        } else {
                set filtered_pools {}
        }
        # Only call if NEED-POOL headers exist
        if { $dns_enabled && $dns_available } {
            if { [HTTP::header exists "X-Need-DNS-Count"] } {
                set dns_result [call process_headers $client_debug_enabled "dns" $dns_enabled $dns_available]
                set need_dns_lookup [lindex $dns_result 1]
                } else {
                    set need_dns_lookup ""
                    }
            } else {
                set need_dns_lookup ""
                log local0. "DEBUG: DNS unavailable - using IP-only mode for this request"
            }
            # Pool data collection using memory-optimized procedures
            set current_timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
			# Extract instance ID from request header for response inclusion
			set instance_id ""
			if { [HTTP::header exists "X-Instance-ID"] } {
					set instance_id [HTTP::header "X-Instance-ID"]
					if { $client_debug_enabled } {
						log local0. "DEBUG: Request instance ID: $instance_id"
						}
                }
            set available_pools [class names datagroup-dashboard-pools]
            array set dns_request_cache {}
            if { $client_debug_enabled } {
                log local0. "DEBUG: Starting pool data collection - [llength $available_pools] pools configured"
            }
            set pools_data [call collect_all_pool_data $available_pools $dns_enabled $dns_available $need_dns_lookup $client_debug_enabled $filtered_pools dns_request_cache]
            # Build JSON response
            set pools_json "\{\"hostname\":\"$bigip_hostname\",\"timestamp\":\"$current_timestamp\",\"debug_enabled\":\"[expr {$client_debug_enabled ? "enabled" : "disabled"}]\",\"instanceId\":\"$instance_id\",\"pools\":\[$pools_data\]\}"
            if { $client_debug_enabled } {
                log local0. "DEBUG: JSON Response processing completed - [string length $pools_json] bytes response"
            }
            # Send JSON response
            HTTP::respond 200 content $pools_json \
                "Content-Type" "application/json; charset=utf-8" \
                "Cache-Control" "no-cache, no-store, must-revalidate" \
                "Pragma" "no-cache" \
                "Expires" "0" \
                "Connection" "Close" \
                "X-Content-Type-Options" "nosniff"
            event disable
            return
        } else {
# ======================================================================================================
# REMOTE API ENDPOINT - /api/proxy/pools
# ======================================================================================================
            # Determine backend VIP for target site
            set backend_vip [class lookup $selected_site datagroup-dashboard-api-host]
            if { $backend_vip ne "" } {
                if { $client_debug_enabled } {
                    log local0. "DEBUG: Found backend VIP $backend_vip for site $selected_site"
                }
                # Check if backend VIP is UP
                if { ![catch {LB::status pool $dashboard_api_hosts_pool member $backend_vip 443} member_status] && $member_status eq "up" } {
                    if { $client_debug_enabled } {
                        log local0. "DEBUG: Member $backend_vip:443 is UP - proxy to backend (backend handles DNS)"
                    }
                    # Configure backend authentication - read API key fresh each time
                    set api_keys_list [class names datagroup-dashboard-api-keys]
                    if { [llength $api_keys_list] > 0 } {
                        set fresh_api_key [lindex $api_keys_list 0]
                        HTTP::header insert "X-API-Key" $fresh_api_key
                        # Forward debug client information
                        if { [class match [IP::client_addr] equals datagroup-dashboard-debug] } {
                            HTTP::header insert "X-Forwarded-Debug-Client" "[IP::client_addr]"
                        }
                    } else {
                        call send_error_response 503 "Configuration Error" "No API keys configured for backend authentication" "No API keys configured in datagroup-dashboard-api-keys"
                        return
                    }
                    # Forward to backend member
                    pool $dashboard_api_hosts_pool member $backend_vip 443
                } else {
                    call send_error_response 503 "Backend Error" "The API Endpoint for $selected_site is currently unavailable" "Backend member $backend_vip:443 is not UP"
                    log local0. "DEBUG: Member $backend_vip:443 for site $selected_site is DOWN"
                    return
                }
            } else {
                call send_error_response 503 "Configuration Error" "No API Endpoint information found for $selected_site<br><br>Please verify Site-to-IP mapping exists in datagroup-dashboard-api-host" "No backend VIP found for site $selected_site in datagroup-dashboard-api-host
                log local0. "DEBUG: Site $selected_site is not currently mapped to a backend VIP""
                return
            }
            return
        }
    }
# ======================================================================================================
# AJAX PARAMETER HANDLER - Unified preference management
# ======================================================================================================
    if { [HTTP::method] eq "POST" && [string match "*=*" [HTTP::query]] } {
        # Parse parameter type and value using pattern matching
        switch -glob [HTTP::query] {
            "refresh=*" {
                set param_type "refresh"
                set param_value [URI::decode [string range [HTTP::query] 8 end]]
            }
            "theme=*" {
                set param_type "theme"
                set param_value [URI::decode [string range [HTTP::query] 6 end]]
            }
            "viewmode=*" {
                set param_type "viewmode"
                set param_value [URI::decode [string range [HTTP::query] 9 end]]
            }
            default {
                # Unrecognized AJAX parameter
                return
            }
        }
        # Process parameter through unified validation handler
        call process_ajax_parameter $param_type $param_value
        event disable
        return
    }
# ======================================================================================================
# STATIC FILE SERVING - CSS, JavaScript, and Image
# ======================================================================================================
    set request_uri [HTTP::uri]
    switch $request_uri {
        "/dashboard_logo.png" -
        "/dashboard_themes.css" -
        "/dashboard_js-core.js" -
        "/dashboard_js-data.js" -
        "/dashboard_js-ui.js" -
        "/dashboard_js-client.js" -
        "/dashboard_js-logger.js" {
            # Determine file properties
            set filename [string trimleft $request_uri "/"]
            # Set appropriate content type
            if { [string match "*.css" $request_uri] } {
                set content_type "text/css; charset=utf-8"
            } elseif { [string match "*.js" $request_uri] } {
                set content_type "application/javascript; charset=utf-8"
            } else {
                set content_type "image/png"
            }
            # Serve static file with caching headers
            HTTP::respond 200 content [ifile get $filename] \
                "Content-Type" $content_type \
                "Cache-Control" "public, max-age=86400" \
                "Connection" "Close" \
                "X-Content-Type-Options" "nosniff"
            event disable
            return
        }
    }
# ======================================================================================================
# MAIN DASHBOARD HTML GENERATION
# ======================================================================================================
    # Site configuration - Available sites and dropdown generation
    set available_sites_raw [class names datagroup-dashboard-sites]
    set sites_with_order {}
    foreach site $available_sites_raw {
        set order_value [class lookup $site datagroup-dashboard-sites]
        if { $order_value eq "" } {
            set order_value 999
        }
        lappend sites_with_order [list $site $order_value]
    }
    # Sort sites by configured order value
    set sorted_sites [lsort -integer -index 1 $sites_with_order]
    # Extract sorted site names
    set available_sites {}
    foreach site_pair $sorted_sites {
        lappend available_sites [lindex $site_pair 0]
    }
    if { $client_debug_enabled } {
        log local0. "DEBUG: Available sites count: [llength $available_sites] - $available_sites"
    }
    # User preference loading - Cookie validation and defaults
    # Process refresh_interval cookie
    set valid_refresh_intervals {10 30 60 90}
    set refresh_interval 30
    if { [HTTP::cookie exists "refresh_interval"] } {
        set cookie_value [HTTP::cookie "refresh_interval"]
        if { [lsearch -exact $valid_refresh_intervals $cookie_value] != -1 } {
            set refresh_interval $cookie_value
        }
    }
    # Process theme_preference cookie  
    set current_theme "theme1"
    if { [HTTP::cookie exists "theme_preference"] } {
        set cookie_value [HTTP::cookie "theme_preference"]
        if { [lsearch -exact {theme1 theme2 theme3} $cookie_value] != -1 } {
            set current_theme $cookie_value
        }
    }
    # Process view_mode cookie
    set current_viewmode "micro"
    if { [HTTP::cookie exists "view_mode"] } {
        set cookie_value [HTTP::cookie "view_mode"]
        if { [lsearch -exact {macro micro} $cookie_value] != -1 } {
            set current_viewmode $cookie_value
        }
    }
    # Site selection 
    set selected_site ""
    # HTML response generation - dashboard page assembly
    # Build site selector dropdown HTML
    set site_selector_html "
    <div class=\"site-selector-container\">
      <label for=\"siteSelect\"></label>
      <select id=\"siteSelect\" onchange=\"changeSite(this.value)\" title=\"Site selection\">"
    # Add default option (always selected initially)
    append site_selector_html "
        <option value=\"\" selected>Select a site...</option>"
    # Add visual separator
    append site_selector_html "
        <option value=\"\" disabled>───────────────────</option>"
    # Add available sites (none pre-selected)
    foreach site $available_sites {
        set site_display $site
        append site_selector_html "
        <option value=\"$site\">$site_display</option>"
    }
    append site_selector_html "
      </select>
    </div>"
# Generate complete HTML response
set html_response "<!DOCTYPE html>
<html lang=\"en\">
<head>
  <meta charset=\"UTF-8\">
  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">
  <title>Application Dashboard</title>
  <link rel=\"stylesheet\" type=\"text/css\" href=\"/dashboard_themes.css\" id=\"theme-css\">
  <style>
body{transition:background-color .3s ease,color .3s ease;opacity:0}
.theme-switching{transition:all .3s ease}
body.theme-loaded{opacity:1;transition:opacity .3s ease}
</style>
</head>
<body data-theme=\"$current_theme\">
  <header>
    <div class=\"header-left\">
      <a href=\"https://$bigip_hostname\" target=\"$bigip_hostname\">
        <img src=\"/dashboard_logo.png\" alt=\"Dashboard Logo\">
      </a>
      <h2>Application Dashboard</h2>
    </div>
    <div class=\"header-right\">
      <button class=\"logout-button-header\" onclick=\"window.location.href='/my.logout.php3'\">Log Out</button>
    </div>
  </header>
  <div class=\"container\">
    <div id=\"loading-message\" class=\"loading-message\" style=\"display: none;\">
      <h3>Loading pool data...</h3>
      <p>Fetching data from selected site...</p>
    </div>
    <div id=\"no-site-message\" class=\"no-site-message\">
      <h3>No Site Selected</h3>
      <p>Select a site from the dropdown below.</p>
    </div>
    <div id=\"error-message\" class=\"error-message\" style=\"display: none;\">
      <h3>Unable to retrieve pool data</h3>
      <p id=\"error-details\">Unable to connect to the selected site.</p>
      <button onclick=\"loadPoolData()\" class=\"retry-button\">Retry</button>
    </div>
    <div class=\"pools-grid\" id=\"pools-grid\" style=\"display: none;\"></div>
  </div>
  <div class=\"bottom-bar\">
    <div class=\"refresh-timer-container\">
      <div class=\"refresh-notice\">Auto-refresh: <span id=\"countdown\">$refresh_interval</span>s</div>
      <select id=\"refreshSelect\" onchange=\"changeRefreshInterval(this.value)\" title=\"Auto-refresh interval\">"
    foreach option $valid_refresh_intervals {
        if { $option == $refresh_interval } {
            append html_response "
            <option value=\"$option\" selected>${option}s</option>"
        } else {
            append html_response "
            <option value=\"$option\">${option}s</option>"
        }
    }
    append html_response "
      </select>
      $site_selector_html
    </div>
    <div class=\"theme-toggle-container\">
      <button class=\"alias-toggle\" onclick=\"toggleAlias()\">Alias</button>
      <button class=\"mode-toggle\" onclick=\"toggleViewMode()\">Mode</button>
      <button class=\"logger-toggle\" onclick=\"toggleLogger()\">Logs</button>
      <button class=\"flush-toggle\" onclick=\"flushDNSCache()\">Flush</button>
      <button class=\"resolve-toggle\" onclick=\"resolveDNS()\">Resolve</button>
      <button class=\"theme-toggle\" onclick=\"toggleTheme()\">Theme</button>
    </div>
  </div>
  <script>
    window.dashboardConfig = {
        currentSite: '',
        refreshInterval: $refresh_interval,
        currentTheme: '$current_theme',
        currentViewMode: '$current_viewmode',
        debugEnabled: $client_debug_enabled
    };
  </script>
  <script src=\"/dashboard_js-core.js\"></script>
  <script src=\"/dashboard_js-client.js\"></script>
  <script src=\"/dashboard_js-data.js\"></script>
  <script src=\"/dashboard_js-ui.js\"></script>
  <script src=\"/dashboard_js-logger.js\"></script>
</body>
</html>"
    # Send HTTP response with security headers and session cookies
    HTTP::respond 200 content $html_response \
        "Content-Type" "text/html; charset=utf-8" \
        "Set-Cookie" "theme_preference=$current_theme; Path=/; Max-Age=604800; HttpOnly; Secure;" \
        "Set-Cookie" "refresh_interval=$refresh_interval; Path=/; Max-Age=604800; HttpOnly; Secure;" \
        "Set-Cookie" "view_mode=$current_viewmode; Path=/; Max-Age=604800; HttpOnly; Secure;" \
        "Cache-Control" "no-cache, no-store, must-revalidate" \
        "Pragma" "no-cache" \
        "Expires" "0" \
        "X-Frame-Options" "SAMEORIGIN" \
        "X-Content-Type-Options" "nosniff" \
        "X-XSS-Protection" "1; mode=block" \
        "Referrer-Policy" "strict-origin-when-cross-origin" \
        "Connection" "Close"
    event disable
}
# UTILITY PROCEDURES
# ======================================================================================================
# Procedure for processing NEED-POOL/NEED-DNS header requests
# ======================================================================================================
# @param client_debug_enabled - Whether debug logging is enabled
# @param header_type - Type of headers to process ("pools" or "dns")
# @param dns_enabled - Whether DNS is enabled (used for DNS headers)
# @param dns_available - Whether DNS pool is available (used for DNS headers)
# @returns:
# For "pools": List of requested pool names
# For "dns": List containing [need_dns_list, need_dns_lookup]
proc process_headers { client_debug_enabled header_type {dns_enabled 0} {dns_available 0} } {
    switch $header_type {
        "pools" {
            # Process Pool headers
            set need_pools_list {}
            set header_count 0
            if { [catch {set header_count [HTTP::header "X-Need-Pools-Count"]} parse_error] } {
                if { $client_debug_enabled } {
                    log local0. "DEBUG: Invalid X-Need-Pools-Count header format - using 0"
                }
                set header_count 0
            } else {
                # Validate header count is reasonable (prevent abuse)
                if { $header_count < 0 || $header_count > 50 } {
                    if { $client_debug_enabled } {
                        log local0. "DEBUG: X-Need-Pools-Count out of range ($header_count) - using 0"
                    }
                    set header_count 0
                }
            }
            # Process each numbered header if any exist
            if { $header_count > 0 } {
                if { $client_debug_enabled } {
                    log local0. "DEBUG: Processing $header_count need-pools headers from client"
                }
                for { set i 1 } { $i <= $header_count } { incr i } {
                    set header_name "X-Need-Pools-$i"
                    if { [HTTP::header exists $header_name] } {
                        if { [catch {
                            set chunk_pools [HTTP::header $header_name]
                            set chunk_list [split $chunk_pools ","]
                            foreach pool $chunk_list {
                                set pool [string trim $pool]
                                # Validate pool name format (basic safety check)
                                if { $pool ne "" && [string length $pool] >= 1 && [string length $pool] <= 100 } {
                                    lappend need_pools_list $pool
                                } elseif { $client_debug_enabled && $pool ne "" } {
                                    log local0. "DEBUG: Skipping invalid pool name: $pool"
                                }
                            }
                        } chunk_error] } {
                            if { $client_debug_enabled } {
                                log local0. "DEBUG: Error processing header $header_name - skipping: $chunk_error"
                            }
                        }
                    }
                }
                if { $client_debug_enabled && [llength $need_pools_list] > 0 } {
                    log local0. "DEBUG: Built need-pools list for [llength $need_pools_list] pools"
                }
            }
            return $need_pools_list
        }
        "dns" {
            # Process DNS headers
            set need_dns_list {}
            set need_dns_lookup ""
            set header_count 0
            # Only process DNS headers if DNS is enabled and available
            if { $dns_enabled && $dns_available } {
                # Parse X-Need-DNS-Count header to determine number of need headers
                if { [catch {set header_count [HTTP::header "X-Need-DNS-Count"]} parse_error] } {
                    if { $client_debug_enabled } {
                        log local0. "DEBUG: Invalid X-Need-DNS-Count header format - using 0"
                    }
                    set header_count 0
                } else {
                    # Validate header count to prevent abuse
                    if { $header_count < 0 || $header_count > 50 } {
                        if { $client_debug_enabled } {
                            log local0. "DEBUG: X-Need-DNS-Count out of range ($header_count) - using 0"
                        }
                        set header_count 0
                    }
                }
                # Process chunked DNS need headers
                if { $header_count > 0 } {
                    if { $client_debug_enabled } {
                        log local0. "DEBUG: Processing $header_count need-DNS headers from client"
                    }
                    for { set i 1 } { $i <= $header_count } { incr i } {
                        set header_name "X-Need-DNS-IPs-$i"
                        if { [HTTP::header exists $header_name] } {
                            if { [catch {
                                set chunk_ips [HTTP::header $header_name]
                                set chunk_list [split $chunk_ips ","]
                                # Validate and collect IP addresses
                                foreach ip $chunk_list {
                                    set ip [string trim $ip]
                                    if { $ip ne "" && [string length $ip] >= 7 && [string length $ip] <= 45 } {
                                        lappend need_dns_list $ip
                                    }
                                }
                            } chunk_error] } {
                                if { $client_debug_enabled } {
                                    log local0. "DEBUG: Error processing header $header_name - skipping"
                                }
                            }
                        }
                    }
                    # Build fast lookup structure for DNS optimization
                    if { [llength $need_dns_list] > 0 } {
                        set need_dns_lookup " [join $need_dns_list " "] "
                        if { $client_debug_enabled } {
                            log local0. "DEBUG: Built need-DNS lookup structure for [llength $need_dns_list] IPs"
                        }
                    }
                }
            }
            return [list $need_dns_list $need_dns_lookup]
        }
        default {
            # Unknown header type - return appropriate empty values
            return {}
        }
    }
}
# ======================================================================================================
# Procedure for collecting pool processed data
# ======================================================================================================
# @param available_pools - List of pool names to process
# @param need_dns_lookup - Space-padded string of IPs needing DNS resolution
# @param filtered_pools - List of pool names from X-Need-Pools headers
# @returns JSON string containing all processed pools data
proc collect_all_pool_data { available_pools dns_enabled dns_available need_dns_lookup client_debug_enabled filtered_pools cache_var } {
    # Access the cache from the calling scope
    upvar $cache_var dns_request_cache
    # Use filtered pools if headers present, otherwise use all available pools
    set pools_to_process $available_pools
    if { [llength $filtered_pools] > 0 } {
        # Validate that requested pools exist in datagroup 
        set validated_pools {}
        foreach requested_pool $filtered_pools {
            if { [lsearch -exact $available_pools $requested_pool] != -1 } {
                lappend validated_pools $requested_pool
            } 
        }
        if { [llength $validated_pools] > 0 } {
            set pools_to_process $validated_pools
            if { $client_debug_enabled } {
                log local0. "DEBUG: Processing [llength $validated_pools] validated pools from X-Need-Pools headers"
            }
        } else {
            if { $client_debug_enabled } {
                log local0. "DEBUG: No valid pools in headers - falling back to all pools"
            }
        }
    }
    set pool_json_list {}
    # Process each pool
    foreach pool_name $pools_to_process {
        set pool_json [call process_single_pool $pool_name $dns_enabled $dns_available $need_dns_lookup $client_debug_enabled $cache_var]
        lappend pool_json_list $pool_json
    }
    if { $client_debug_enabled } {
        log local0. "DEBUG: Pool data collection completed - [llength $pools_to_process] pools processed out of [llength $available_pools] available pools"
    }
    return [join $pool_json_list ","]
}
# ======================================================================================================
# Procedure for comprehensive single pool processing
# ======================================================================================================
# @param pool_name - Name of the pool to process
# @param need_dns_lookup - Space-padded string of IPs needing DNS resolution
# @returns JSON string for this pool with automatic variable cleanup
proc process_single_pool { pool_name dns_enabled dns_available need_dns_lookup client_debug_enabled cache_var } {
    # Access the cache from the calling scope
    upvar $cache_var dns_request_cache
    # Get sort order with fallback
    set sort_order [class lookup $pool_name datagroup-dashboard-pools]
    if { $sort_order eq "" } {
        set sort_order 999
    }
    # Retrieve pool alias if configured
    set pool_alias "null"
    if { [catch {class lookup $pool_name datagroup-dashboard-pool-alias} alias_value] } {
        set pool_alias "null"
    } else {
        if { $alias_value ne "" } {
            regsub -all {"} $alias_value {\"} alias_escaped
            set pool_alias "\"$alias_escaped\""
        } else {
            set pool_alias "null"
        }
    }
    # Process pool members
    if { [catch {members -list $pool_name} pool_members] } {
        # Handle pool access errors
        if { $client_debug_enabled } {
            log local0. "DEBUG: Error accessing pool $pool_name - treating as UNKNOWN"
        }
        regsub -all {"} $pool_name {\"} pool_name_escaped
        return "\{\"name\":\"$pool_name_escaped\",\"alias\":$pool_alias,\"sort_order\":$sort_order,\"status\":\"UNKNOWN\",\"error\":\"Pool not found or is no longer configured\",\"up_members\":0,\"down_members\":0,\"disabled_members\":0,\"total_members\":0,\"members\":\[\]\}"
    } else {
        # Process valid pool - initialize member counters and JSON list
        set member_json_list {}
        set up_members 0
        set down_members 0
        set disabled_members 0
        # Process each pool member with integrated member processing
        foreach member $pool_members {
            set ip [lindex $member 0]
            set port [lindex $member 1]
            # Query member status
            if { [catch {LB::status pool $pool_name member $ip $port} member_status] } {
                set member_status "unknown"
            }
            # Get hostname result for this IP - IPv6 addresses are not supported for DNS resolution
            if { [string first ":" $ip] != -1 } {
                # IPv6 address detected - skip DNS resolution (v6 not currently supported)
                set hostname_result "null"
            } else {
                # IPv4 address - proceed with DNS resolution
                set hostname_result [call resolve_hostname_for_json $ip $dns_enabled $dns_available $need_dns_lookup $client_debug_enabled]
            }
            # Build member JSON object
            regsub -all {"} $ip {\"} ip_escaped
            set member_json "\{\"ip\":\"$ip_escaped\",\"port\":\"$port\",\"status\":\"$member_status\",\"hostname\":$hostname_result\}"
            lappend member_json_list $member_json
            # Count member states for pool status calculation
            switch $member_status {
                "up" {
                    incr up_members
                }
                "down" {
                    incr down_members
                }
                "disabled" - "session_disabled" {
                    incr disabled_members
                }
            }
        }
        # Calculate overall pool status
        if { $up_members > 0 } {
            set pool_status "UP"
        } elseif { [llength $pool_members] == 0 } {
            set pool_status "EMPTY"
        } elseif { $disabled_members > 0 && $up_members == 0 && $down_members == 0 } {
            set pool_status "DISABLED"
        } else {
            set pool_status "DOWN"
        }
        # Build pool JSON object
        regsub -all {"} $pool_name {\"} pool_name_escaped
        set members_json "\[[join $member_json_list ","]\]"
        return "\{\"name\":\"$pool_name_escaped\",\"alias\":$pool_alias,\"sort_order\":$sort_order,\"status\":\"$pool_status\",\"up_members\":$up_members,\"down_members\":$down_members,\"disabled_members\":$disabled_members,\"total_members\":[llength $pool_members],\"members\":$members_json\}"
    }
}
# ======================================================================================================
# Procedure for DNS PTR Resolution 
# ======================================================================================================
# @param ip - IP address to resolve
# @param need_dns_lookup - Space-padded string of IPs needing DNS
# @returns JSON-ready hostname result: "null" or "\"hostname\""
proc resolve_hostname_for_json { ip dns_enabled dns_available need_dns_lookup client_debug_enabled } {
    # Access the per-request DNS cache from parent scope
    upvar dns_request_cache dns_request_cache
    upvar dashboard_dns_resolver dashboard_dns_resolver
    set hostname_result "null"
    set should_resolve_dns 0
    # Validate IP address before any processing - filter out invalid IPv6 addresses
    if { $ip eq "::" || $ip eq "::0" || $ip eq "0:0:0:0:0:0:0:0" } {
        if { $client_debug_enabled } {
            log local0. "DEBUG: Skipping DNS resolution for invalid IPv6 address: $ip"
        }
        set dns_request_cache($ip) "null"
        return "null"
    }
    # Check DNS availability before any cache access
    if { $dns_enabled && $dns_available } {
        # DNS is available - check if this request actually wants DNS resolution
        if { $need_dns_lookup ne "" } {
            # DNS headers were sent - check cache and proceed with DNS logic
            # Check per-request cache first - if we already resolved this IP in this request, use cached result
            if { [info exists dns_request_cache($ip)] } {
                set cached_result $dns_request_cache($ip)
                if { $client_debug_enabled } {
                    log local0. "DEBUG: Using cached DNS result for IP: $ip, result: $cached_result"
                }
                return $cached_result
            }
            # Check if this IP is in the need-DNS list using fast string search
            set search_result [string first " $ip " $need_dns_lookup]
            if { $search_result != -1 } {
                set should_resolve_dns 1
            }
        } else {
            # No need-DNS headers present - do NOT resolve anything
            set should_resolve_dns 0
            return "null"
        }
    } 
    # Perform DNS lookup
    if { $should_resolve_dns } {
        # Perform timeout-protected DNS lookup
        if { [catch {
            # Convert IPv4 address into its constituent bytes
            set ret [scan $ip {%d.%d.%d.%d} a b c d]
            if { $ret != 4 } {
                # Not a valid IPv4 address - skip DNS resolution
                if { $client_debug_enabled } {
                    log local0. "DEBUG: Skipping DNS resolution for non-IPv4 address: $ip"
                }
                set dns_result ""
            } else {
                # Perform a PTR lookup on the IP address with timeout protection
                if { [catch {
                    set dns_response [RESOLVER::name_lookup "/Common/dashboard-DNS" "$d.$c.$b.$a.in-addr.arpa" PTR]
                    set answer_section [DNSMSG::section $dns_response answer]
                    set first_answer [lindex $answer_section 0]
                    if { $first_answer eq "" } {
                        set dns_result ""
                    } else {
                        # Extract hostname from the answer (last element)
                        set dns_result [lindex $first_answer end]
                    }
                } dns_error] } {
                    set dns_result ""
                }
            }
        } dns_error] } {
            if { $client_debug_enabled } {
                log local0. "DEBUG: DNS lookup failed for $ip - $dns_error"
            }
            set hostname_result "null"
        } else {
            if { $dns_result ne "" } {
                # Clean up the hostname - lowercase and remove trailing dot
                set cleaned_hostname [string tolower [string trimright $dns_result "."]]
                # Escape quotes for JSON safety
                regsub -all {"} $cleaned_hostname {\"} hostname_escaped
                set hostname_result "\"$hostname_escaped\""
            } else {
                set hostname_result "null"
            }
        }
        if { $client_debug_enabled } {
            log local0. "DEBUG: DNS lookup completed for IP: $ip, result: $hostname_result"
        }
    } 
    # Store result in per-request cache to prevent duplicate lookups for member IP in multiple pools
    set dns_request_cache($ip) $hostname_result
    return $hostname_result
}
# ======================================================================================================
# Procedure for processing AJAX parameters with validation and response handling
# ======================================================================================================
# @param param_type - Parameter type (refresh, theme, viewmode)
# @param param_value - Decoded parameter value from client
proc process_ajax_parameter { param_type param_value } {
    upvar client_debug_enabled client_debug_enabled
    # Parameter-specific validation and processing
    switch $param_type {
        "refresh" {
            # Validate refresh interval against allowed values
            if { [lsearch -exact {10 30 60 90} $param_value] == -1 } {
                call send_error_response 400 "Validation Error" "Refresh interval must be 10, 30, 60, or 90 seconds"
                return
            }
            if { $client_debug_enabled } {
                log local0. "DEBUG: AJAX refresh interval change request - setting interval to: $param_value"
            }
            set cookie_name "refresh_interval"
            set response_key "refreshInterval"
        }
        "theme" {
            # Validate theme selection
            if { [lsearch -exact {theme1 theme2 theme3} $param_value] == -1 } {
                call send_error_response 400 "Validation Error" "Theme must be theme1, theme2, or theme3"
                return
            }
            if { $client_debug_enabled } {
                log local0. "DEBUG: AJAX theme change request - setting theme to: $param_value"
            }
            set cookie_name "theme_preference"
            set response_key "theme"
        }
        "viewmode" {
            # Validate view mode selection
            if { [lsearch -exact {macro micro} $param_value] == -1 } {
                call send_error_response 400 "Validation Error" "View mode must be macro or micro"
                return
            }
            if { $client_debug_enabled } {
                log local0. "DEBUG: AJAX view mode change request - setting view mode to: $param_value"
            }
            set cookie_name "view_mode"
            set response_key "viewMode"
        }
        default {
            call send_error_response 400 "Invalid Parameter" "Unknown parameter type: $param_type"
            return
        }
    }
    # Send standardized success response with cookie
    HTTP::respond 200 content "\{\"success\":true,\"$response_key\":\"$param_value\"\}" \
        "Content-Type" "application/json; charset=utf-8" \
        "Set-Cookie" "$cookie_name=$param_value; Path=/; Max-Age=604800; HttpOnly; Secure;" \
        "Cache-Control" "no-cache, no-store, must-revalidate" \
        "Connection" "Close" \
        "X-Content-Type-Options" "nosniff"
}
# ======================================================================================================
# Procedure for sending standardized JSON error responses
# ======================================================================================================
# @param status_code - HTTP status code (400, 500, 503, etc.)
# @param error_type - Error category for client handling
# @param message - Detailed error message for display
proc send_error_response { status_code error_type message {debug_message ""} } {
    # Get the required variables from the main scope
    upvar client_debug_enabled client_debug_enabled
    upvar bigip_hostname_escaped bigip_hostname_escaped
    upvar json_version json_version
    set current_timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
    HTTP::respond $status_code content "\{\"error\":\"$error_type\",\"message\":\"$message\",\"hostname\":\"$bigip_hostname_escaped\",\"timestamp\":\"$current_timestamp\",\"version\":\"$json_version\"\}" \
        "Content-Type" "application/json; charset=utf-8" \
        "Cache-Control" "no-cache, no-store, must-revalidate" \
        "Connection" "Close" \
        "X-Content-Type-Options" "nosniff"
    event disable
}
