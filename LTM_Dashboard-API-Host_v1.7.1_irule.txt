# LTM_Dashboard-API-Host_v1.7.1_irule
# Dashboard Version 1.7 
# JSON Version 1.7
# Date: September 2025
# Author: Eric Haupt
# License: MIT
# Copyright (c) 2025 Eric Haupt
# Released under the MIT License. See LICENSE file for details.
#
# Description:
#   This iRule provides a JSON-enabled backend API endpoint for the multi-site dashboard.  
#   Note that dashboard v1.7 is not multi-partition compatible. 
#   
# Dashboard API Hosts Critical Dependencies:
#
#    1. API Host LTM datagroup: datagroup-dashboard-trusted-frontends
#        Datagroup type: Address
#
#    2. API Host LTM datagroup: datagroup-dashboard-api-keys
#		Type: String, Used to authenticate Front-end to API host
#
#    3. API Host LTM datagroup: datagroup-dashboard-pools
#		Type: String, Used to provide a list of pools to display
#
#    4. API Host LTM datagroup: datagroup-dashboard-pool-alias
#		Type: String, Used to create alias names for actual pool names
#
#    5. API Host LTM Pool: dashboard-dns_udp53_pool
#       This pool contains the DNS listener for monitoring
#
#    6. API Host LTM dns-resolver: /Common/dashboard-DNS 
#       This resolver should map to a GTM listener dedicated for dashboard and scoped for in-addr.arpa
#
# API Endpoints:
#   
#    /api/proxy/pools - Returns JSON array of pool status and member data (requires API key)
#    /api/health - Returns health status of the API endpoint (no auth)
#

when CLIENT_ACCEPTED {
# ======================================================================================================
# USER CONFIGURATION VARIABLES - Set Debug enable, DNS enable, Dashboard pool name, and Resolver name 
# ======================================================================================================
   
    # Dashboard Debug toggle - set to 1 to enable Dashboard debug, 0 to disable
    set debug_enabled 0

    # Dashboard DNS toggle - set to 1 to enable Dashboard DNS, 0 to disable
    set dns_enabled 1

    # Dashboard Pool Name - Update this pool name variable to match your environment
    set dashboard_dns_pool "dashboard-dns_udp53_pool"
    
    # Dashboard DNS Resolver Name - Update this pool name variable to match your environment
    set dashboard_dns_resolver "/Common/dashboard-DNS"

# ======================================================================================================
# END CONFIGURATION VARIABLES - Do not modify any variables below this line
# ======================================================================================================
    # Restrict access to authorized dashboard front-ends Self-IPs
    if { ![class match [IP::client_addr] equals datagroup-dashboard-trusted-frontends] } {
        drop
    }
    # JSON Schema version
    set json_version "1.7"
    # Cache hostname values once
    set bigip_hostname [info hostname]
    regsub -all {"} $bigip_hostname {\"} bigip_hostname_escaped
    # DNS resilience configuration (do not modify this)
    set dns_available 0
    if { $dns_enabled } {
        if { ![catch {active_members $dashboard_dns_pool} active_count] } {
            if { $active_count > 0 } {
                set dns_available 1
            }
        }
    }
}
when HTTP_REQUEST {
    # Check debug authorization from frontend via X-Forwarded-Debug-Client header
    # Only process debug if backend debug is enabled
    set client_debug_enabled 0
    set debug_client_ip ""
    if { $debug_enabled && [HTTP::header exists "X-Forwarded-Debug-Client"] } {
        set debug_client_ip [HTTP::header "X-Forwarded-Debug-Client"]
        set client_debug_enabled 1
        log local0. "DEBUG: Debug enabled for end-user client: $debug_client_ip (forwarded by frontend [IP::client_addr])"
    }
    if { $client_debug_enabled } {
        log local0. "DEBUG: [HTTP::method] [HTTP::uri] from frontend [IP::client_addr] for end-user $debug_client_ip - Host: [HTTP::host]"
    }
    # Validate HTTP method for all endpoints
    if { [HTTP::method] ne "GET" } {
        if { $client_debug_enabled } {
            log local0. "ERROR: Invalid method [HTTP::method] for [HTTP::uri] - returning 405"
        }
        call send_error_response 405 "Method Error" "Only GET method is supported"
        return
    }
# ======================================================================================================
# API ENDPOINT - /api/health
# ======================================================================================================
    if { [HTTP::uri] eq "/api/health" } {
        set current_timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
        set uptime_seconds [clock seconds]
        set version $json_version
        # Get pool configuration from datagroup with error handling
        set available_pools [class names datagroup-dashboard-pools]
        set pools_configured [llength $available_pools]
        # Determine health status based on endpoint configuration
        if { $pools_configured > 0 } {
            set health_status "healthy"
            set health_message "API endpoint is operational with $pools_configured pools configured"
        } else {
            set health_status "unhealthy"
            set health_message "API endpoint has no pools configured for monitoring"
        }
        # Escape health message for JSON safety
        regsub -all {"} $health_message {\"} message_escaped
        # Build health response JSON
        set health_json "\{\"status\":\"$health_status\",\"hostname\":\"$bigip_hostname_escaped\",\"timestamp\":\"$current_timestamp\",\"uptime_seconds\":$uptime_seconds,\"version\":\"$version\",\"pools_configured\":$pools_configured,\"message\":\"$message_escaped\"\}"
        # Determine HTTP status code based on health
        set http_status 200
        if { $health_status eq "unhealthy" } {
            set http_status 503
        }
        # Send health response with appropriate headers
        HTTP::respond $http_status content $health_json \
            "Content-Type" "application/json; charset=utf-8" \
            "Cache-Control" "no-cache, no-store, must-revalidate" \
            "Pragma" "no-cache" \
            "Expires" "0" \
            "Connection" "Close"
        event disable
        return
    }
# ======================================================================================================
# API ENDPOINT - /api/proxy/pools
# ======================================================================================================
    if { [HTTP::uri] contains "/api/proxy/pools" } {
        # API KEY - Required for data endpoints
        # Check for X-API-Key header presence
        if { ![HTTP::header exists "X-API-Key"] } {
            call send_error_response 403 "Authentication Error" "Missing X-API-Key header" "API request rejected - Missing X-API-Key header from [IP::client_addr] for [HTTP::uri]"
            return
        }
        # Validate API key exists in datagroup
        set provided_api_key [HTTP::header "X-API-Key"]
        if { [catch {class match $provided_api_key equals datagroup-dashboard-api-keys} api_key_valid] || !$api_key_valid } {
            call send_error_response 403 "Authentication Error" "Invalid API key" "API request rejected - Invalid API key from [IP::client_addr] for [HTTP::uri]"
            return
        }
        # Only call if NEED-POOL headers exist
        if { [HTTP::header exists "X-Need-Pools-Count"] } {
            set filtered_pools [call process_headers $client_debug_enabled "pools"]
        } else {
            set filtered_pools {}
        }
        # DNS header parsing
        # Only call if NEED-DNS headers exist and DNS is available
        if { $dns_enabled && $dns_available } {
            if { [HTTP::header exists "X-Need-DNS-Count"] } {
                set dns_result [call process_headers $client_debug_enabled "dns" $dns_enabled $dns_available]
                set need_dns_list [lindex $dns_result 0]
                set need_dns_lookup [lindex $dns_result 1]
                } else {
                    set need_dns_list {}
                    set need_dns_lookup ""
                    }
            } else {
                set need_dns_list {}
                set need_dns_lookup ""
                log local0. "DEBUG: DNS unavailable - using IP-only mode for this request"
        }
        # Initialize response data
        set current_timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
		# Extract instance ID from request header for response inclusion
		set instance_id ""
		if { [HTTP::header exists "X-Instance-ID"] } {
			set instance_id [HTTP::header "X-Instance-ID"]
			if { $client_debug_enabled } {
				log local0. "DEBUG: Request instance ID: $instance_id"
				}
             }
        set available_pools [class names datagroup-dashboard-pools]
        if { $client_debug_enabled } {
            log local0. "DEBUG: Starting pool data collection - [llength $available_pools] pools configured"
        }
        # Use memory-optimized procedure for pool processing with filtering support
        set pools_data [call collect_all_pool_data $available_pools $dns_enabled $dns_available $need_dns_lookup $client_debug_enabled $filtered_pools dns_request_cache]
        # Build final JSON response
        set pools_json "\{\"hostname\":\"$bigip_hostname_escaped\",\"timestamp\":\"$current_timestamp\",\"debug_enabled\":\"[expr {($debug_enabled && $client_debug_enabled) ? "enabled" : "disabled"}]\",\"instanceId\":\"$instance_id\",\"pools\":\[$pools_data\]\}"
        if { $client_debug_enabled } {
            log local0. "DEBUG: JSON Response processing completed - [string length $pools_json] bytes response"
        }
        if { $client_debug_enabled && $dns_enabled && $dns_available && [llength $need_dns_list] > 0 } {
            log local0. "DEBUG: DNS resolution completed for [llength $need_dns_list] IPs"
        }
        # Send JSON response with comprehensive headers
        HTTP::respond 200 content $pools_json \
            "Content-Type" "application/json; charset=utf-8" \
            "Cache-Control" "no-cache, no-store, must-revalidate" \
            "Pragma" "no-cache" \
            "Expires" "0" \
            "Connection" "Close"
        event disable
        return
    }
    # DEFAULT 404 HANDLER - For unrecognized URIs
    call send_error_response 404 "Endpoint Error" "The requested endpoint does not exist"
    event disable
}
# UTILITY PROCEDURES
# ======================================================================================================
# Procedure for processing NEED-POOL/DNS header requests
# ======================================================================================================
# @param client_debug_enabled - Whether debug logging is enabled
# @param header_type - Type of headers to process ("pools" or "dns")
# @param dns_enabled - Whether DNS is enabled (used for DNS headers)
# @param dns_available - Whether DNS pool is available (used for DNS headers)
# @returns:
# For "pools": List of requested pool names
# For "dns": List containing [need_dns_list, need_dns_lookup]
proc process_headers { client_debug_enabled header_type {dns_enabled 0} {dns_available 0} } {
    switch $header_type {
        "pools" {
            # Process Pool headers
            set need_pools_list {}
            set header_count 0
            if { [catch {set header_count [HTTP::header "X-Need-Pools-Count"]} parse_error] } {
                if { $client_debug_enabled } {
                    log local0. "DEBUG: Invalid X-Need-Pools-Count header format - using 0"
                }
                set header_count 0
            } else {
                # Validate header count is reasonable (prevent abuse)
                if { $header_count < 0 || $header_count > 50 } {
                    if { $client_debug_enabled } {
                        log local0. "DEBUG: X-Need-Pools-Count out of range ($header_count) - using 0"
                    }
                    set header_count 0
                }
            }
            # Process each numbered header if any exist
            if { $header_count > 0 } {
                if { $client_debug_enabled } {
                    log local0. "DEBUG: Processing $header_count need-pools headers from client"
                }
                for { set i 1 } { $i <= $header_count } { incr i } {
                    set header_name "X-Need-Pools-$i"
                    if { [HTTP::header exists $header_name] } {
                        if { [catch {
                            set chunk_pools [HTTP::header $header_name]
                            set chunk_list [split $chunk_pools ","]
                            foreach pool $chunk_list {
                                set pool [string trim $pool]
                                # Validate pool name format (basic safety check)
                                if { $pool ne "" && [string length $pool] >= 1 && [string length $pool] <= 100 } {
                                    lappend need_pools_list $pool
                                } elseif { $client_debug_enabled && $pool ne "" } {
                                    log local0. "DEBUG: Skipping invalid pool name: $pool"
                                }
                            }
                        } chunk_error] } {
                            if { $client_debug_enabled } {
                                log local0. "DEBUG: Error processing header $header_name - skipping: $chunk_error"
                            }
                        }
                    }
                }
                if { $client_debug_enabled && [llength $need_pools_list] > 0 } {
                    log local0. "DEBUG: Built need-pools list for [llength $need_pools_list] pools"
                }
            }
            return $need_pools_list
        }
        "dns" {
            # Process DNS headers
            set need_dns_list {}
            set need_dns_lookup ""
            set header_count 0
            # Only process DNS headers if DNS is enabled and available
            if { $dns_enabled && $dns_available } {
                # Parse X-Need-DNS-Count header to determine number of need headers
                if { [catch {set header_count [HTTP::header "X-Need-DNS-Count"]} parse_error] } {
                    if { $client_debug_enabled } {
                        log local0. "DEBUG: Invalid X-Need-DNS-Count header format - using 0"
                    }
                    set header_count 0
                } else {
                    # Validate header count to prevent abuse
                    if { $header_count < 0 || $header_count > 50 } {
                        if { $client_debug_enabled } {
                            log local0. "DEBUG: X-Need-DNS-Count out of range ($header_count) - using 0"
                        }
                        set header_count 0
                    }
                }
                # Process chunked DNS need headers
                if { $header_count > 0 } {
                    if { $client_debug_enabled } {
                        log local0. "DEBUG: Processing $header_count need-DNS headers from client"
                    }
                    for { set i 1 } { $i <= $header_count } { incr i } {
                        set header_name "X-Need-DNS-IPs-$i"
                        if { [HTTP::header exists $header_name] } {
                            if { [catch {
                                set chunk_ips [HTTP::header $header_name]
                                set chunk_list [split $chunk_ips ","]
                                # Validate and collect IP addresses
                                foreach ip $chunk_list {
                                    set ip [string trim $ip]
                                    if { $ip ne "" && [string length $ip] >= 7 && [string length $ip] <= 45 } {
                                        lappend need_dns_list $ip
                                    }
                                }
                            } chunk_error] } {
                                if { $client_debug_enabled } {
                                    log local0. "DEBUG: Error processing header $header_name - skipping"
                                }
                            }
                        }
                    }
                    # Build fast lookup structure for DNS optimization
                    if { [llength $need_dns_list] > 0 } {
                        set need_dns_lookup " [join $need_dns_list " "] "
                        if { $client_debug_enabled } {
                            log local0. "DEBUG: Built need-DNS lookup structure for [llength $need_dns_list] IPs"
                        }
                    }
                }
            }
            return [list $need_dns_list $need_dns_lookup]
        }
        default {
            # Unknown header type - return appropriate empty values
            return {}
        }
    }
}
# ======================================================================================================
# Procedure for collecting pool processed data
# ======================================================================================================
# @param available_pools - List of pool names to process
# @param need_dns_lookup - Space-padded string of IPs needing DNS resolution
# @param filtered_pools - List of pool names from X-Need-Pools headers
# @returns JSON string containing all processed pools data
proc collect_all_pool_data { available_pools dns_enabled dns_available need_dns_lookup client_debug_enabled filtered_pools cache_var } {
    # Access the cache from the calling scope
    upvar $cache_var dns_request_cache
    # Use filtered pools if headers present, otherwise use all available pools
    set pools_to_process $available_pools
    if { [llength $filtered_pools] > 0 } {
        # Validate that requested pools exist in datagroup (security measure)
        set validated_pools {}
        foreach requested_pool $filtered_pools {
            if { [lsearch -exact $available_pools $requested_pool] != -1 } {
                lappend validated_pools $requested_pool
            } 
        }
        if { [llength $validated_pools] > 0 } {
            set pools_to_process $validated_pools
            if { $client_debug_enabled } {
                log local0. "DEBUG: Processing [llength $validated_pools] validated pools from X-Need-Pools headers"
            }
        } else {
            if { $client_debug_enabled } {
                log local0. "DEBUG: No valid pools in headers - falling back to all pools"
            }
        }
    }
    set pool_json_list {}
    # Process each pool
    foreach pool_name $pools_to_process {
        set pool_json [call process_single_pool $pool_name $dns_enabled $dns_available $need_dns_lookup $client_debug_enabled $cache_var]
        lappend pool_json_list $pool_json
    }
    if { $client_debug_enabled } {
        log local0. "DEBUG: Pool data collection completed - [llength $pools_to_process] pools processed out of [llength $available_pools] available pools"
    }
    return [join $pool_json_list ","]
}
# ======================================================================================================
# Procedure for comprehensive single pool processing
# ======================================================================================================
# @param pool_name - Name of the pool to process
# @param need_dns_lookup - Space-padded string of IPs needing DNS resolution
# @returns JSON string for this pool with automatic variable cleanup
proc process_single_pool { pool_name dns_enabled dns_available need_dns_lookup client_debug_enabled cache_var } {
    # Access the cache from the calling scope
    upvar $cache_var dns_request_cache
    # Get sort order with fallback
    set sort_order [class lookup $pool_name datagroup-dashboard-pools]
    if { $sort_order eq "" } {
        set sort_order 999
    }
    # Retrieve pool alias if configured
    set pool_alias "null"
    if { [catch {class lookup $pool_name datagroup-dashboard-pool-alias} alias_value] } {
        set pool_alias "null"
    } else {
        if { $alias_value ne "" } {
            regsub -all {"} $alias_value {\"} alias_escaped
            set pool_alias "\"$alias_escaped\""
        } else {
            set pool_alias "null"
        }
    }
    # Process pool members
    if { [catch {members -list $pool_name} pool_members] } {
        # Handle pool access errors
        if { $client_debug_enabled } {
            log local0. "DEBUG: Error accessing pool $pool_name - treating as UNKNOWN"
        }
        regsub -all {"} $pool_name {\"} pool_name_escaped
        return "\{\"name\":\"$pool_name_escaped\",\"alias\":$pool_alias,\"sort_order\":$sort_order,\"status\":\"UNKNOWN\",\"error\":\"Pool not found or is no longer configured\",\"up_members\":0,\"down_members\":0,\"disabled_members\":0,\"total_members\":0,\"members\":\[\]\}"
    } else {
        # Process valid pool - initialize member counters and JSON list
        set member_json_list {}
        set up_members 0
        set down_members 0
        set disabled_members 0
        # Process each pool member with integrated member processing
        foreach member $pool_members {
            set ip [lindex $member 0]
            set port [lindex $member 1]
            # Query member status
            if { [catch {LB::status pool $pool_name member $ip $port} member_status] } {
                set member_status "unknown"
            }
            # Get hostname result for this IP - IPv6 addresses are not supported for DNS resolution
            if { [string first ":" $ip] != -1 } {
                # IPv6 address detected - skip DNS resolution (v6 not currently supported)
                set hostname_result "null"
            } else {
                # IPv4 address - proceed with DNS resolution
                set hostname_result [call resolve_hostname_for_json $ip $dns_enabled $dns_available $need_dns_lookup $client_debug_enabled]
            }
            # Build member JSON object
            regsub -all {"} $ip {\"} ip_escaped
            set member_json "\{\"ip\":\"$ip_escaped\",\"port\":\"$port\",\"status\":\"$member_status\",\"hostname\":$hostname_result\}"
            lappend member_json_list $member_json
            # Count member states for pool status calculation
            switch $member_status {
                "up" {
                    incr up_members
                }
                "down" {
                    incr down_members
                }
                "disabled" - "session_disabled" {
                    incr disabled_members
                }
            }
        }
        # Calculate overall pool status
        if { $up_members > 0 } {
            set pool_status "UP"
        } elseif { [llength $pool_members] == 0 } {
            set pool_status "EMPTY"
        } elseif { $disabled_members > 0 && $up_members == 0 && $down_members == 0 } {
            set pool_status "DISABLED"
        } else {
            set pool_status "DOWN"
        }
        # Build pool JSON object
        regsub -all {"} $pool_name {\"} pool_name_escaped
        set members_json "\[[join $member_json_list ","]\]"
        return "\{\"name\":\"$pool_name_escaped\",\"alias\":$pool_alias,\"sort_order\":$sort_order,\"status\":\"$pool_status\",\"up_members\":$up_members,\"down_members\":$down_members,\"disabled_members\":$disabled_members,\"total_members\":[llength $pool_members],\"members\":$members_json\}"
    }
}
# ======================================================================================================
# Procedure for DNS PTR Resolution 
# ======================================================================================================
# @param ip - IP address to resolve
# @param need_dns_lookup - Space-padded string of IPs needing DNS
# @returns JSON-ready hostname result: "null" or "\"hostname\""
proc resolve_hostname_for_json { ip dns_enabled dns_available need_dns_lookup client_debug_enabled } {
    # Access the per-request DNS cache from parent scope
    upvar dns_request_cache dns_request_cache
    upvar dashboard_dns_resolver dashboard_dns_resolver
    set hostname_result "null"
    set should_resolve_dns 0
    # Validate IP address before any processing - filter out invalid IPv6 addresses
    if { $ip eq "::" || $ip eq "::0" || $ip eq "0:0:0:0:0:0:0:0" } {
        if { $client_debug_enabled } {
            log local0. "DEBUG: Skipping DNS resolution for invalid IPv6 address: $ip"
        }
        set dns_request_cache($ip) "null"
        return "null"
    }
    # Check DNS availability FIRST, before any cache access
    if { $dns_enabled && $dns_available } {
        # DNS is available - check if this request actually wants DNS resolution
        if { $need_dns_lookup ne "" } {
            # DNS headers were sent - check cache and proceed with DNS logic
            # Check per-request cache first - if we already resolved this IP in this request, use cached result
            if { [info exists dns_request_cache($ip)] } {
                set cached_result $dns_request_cache($ip)
                if { $client_debug_enabled } {
                    log local0. "DEBUG: Using cached DNS result for IP: $ip, result: $cached_result"
                }
                return $cached_result
            }
            # Check if this IP is in the need-DNS list using fast string search
            set search_result [string first " $ip " $need_dns_lookup]
            if { $search_result != -1 } {
                set should_resolve_dns 1
            }
        } else {
            # No need-DNS headers present - do NOT resolve anything
            set should_resolve_dns 0
            return "null"
        }
    } 
    # Perform DNS lookup
    if { $should_resolve_dns } {
        # Perform timeout-protected DNS lookup
        if { [catch {
            # Convert IPv4 address into its constituent bytes
            set ret [scan $ip {%d.%d.%d.%d} a b c d]
            if { $ret != 4 } {
                # Not a valid IPv4 address - skip DNS resolution
                if { $client_debug_enabled } {
                    log local0. "DEBUG: Skipping DNS resolution for non-IPv4 address: $ip"
                }
                set dns_result ""
            } else {
                # Perform a PTR lookup on the IP address with timeout protection
                if { [catch {
                    set dns_response [RESOLVER::name_lookup $dashboard_dns_resolver "$d.$c.$b.$a.in-addr.arpa" PTR]
                    set answer_section [DNSMSG::section $dns_response answer]
                    set first_answer [lindex $answer_section 0]
                    if { $first_answer eq "" } {
                        set dns_result ""
                    } else {
                        # Extract hostname from the answer (last element)
                        set dns_result [lindex $first_answer end]
                    }
                } dns_error] } {
                    set dns_result ""
                }
            }
        } dns_error] } {
            if { $client_debug_enabled } {
                log local0. "DEBUG: DNS lookup failed for $ip - $dns_error"
            }
            set hostname_result "null"
        } else {
            if { $dns_result ne "" } {
                # Clean up the hostname - lowercase and remove trailing dot
                set cleaned_hostname [string tolower [string trimright $dns_result "."]]
                # Escape quotes for JSON safety
                regsub -all {"} $cleaned_hostname {\"} hostname_escaped
                set hostname_result "\"$hostname_escaped\""
            } else {
                set hostname_result "null"
            }
        }
        if { $client_debug_enabled } {
            log local0. "DEBUG: DNS lookup completed for IP: $ip, result: $hostname_result"
        }
    } 
    # Store result in per-request cache to prevent duplicate lookups for member IP in multiple pools
    set dns_request_cache($ip) $hostname_result
    return $hostname_result
}
# ======================================================================================================
# Procedure for sending standardized JSON error responses
# ======================================================================================================
# @param status_code - HTTP status code (400, 500, 503, etc.)
# @param error_type - Error category for client handling
# @param message - Detailed error message for display
proc send_error_response { status_code error_type message {debug_message ""} } {
    # Get the required variables from the main scope
    upvar client_debug_enabled client_debug_enabled
    upvar bigip_hostname_escaped bigip_hostname_escaped
    upvar json_version json_version
    set current_timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
    HTTP::respond $status_code content "\{\"error\":\"$error_type\",\"message\":\"$message\",\"hostname\":\"$bigip_hostname_escaped\",\"timestamp\":\"$current_timestamp\",\"version\":\"$json_version\"\}" \
        "Content-Type" "application/json; charset=utf-8" \
        "Cache-Control" "no-cache, no-store, must-revalidate" \
        "Connection" "Close" \
        "X-Content-Type-Options" "nosniff"
    event disable
}